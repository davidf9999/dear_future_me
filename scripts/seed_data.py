import asyncio
import json  # or csv
import uuid
from pathlib import Path

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from app.auth.models import SafetyPlanTable, UserProfileTable, UserTable
from app.db.session import (
    get_async_session_context,  # Assuming you have 'engine' for create_all
)

# If you need to create users with FastAPI-Users (e.g., for hashed passwords)
# This setup is a bit more involved as get_user_manager needs a request-like object
# or you might need to adapt user creation.
# For simple seeding without password hashing concerns, direct DB insertion is easier.


async def create_db_and_tables():
    # This is usually handled by Alembic, but for a fresh seed, you might ensure tables exist
    # Or rely on your test setup / Alembic to have created them.
    # from app.auth.models import Base
    # async with engine.begin() as conn:
    #     await conn.run_sync(Base.metadata.create_all)
    pass


async def seed_user_data(db: AsyncSession, user_data: dict):
    # Check if user exists
    user_email = user_data.get("email")
    if not user_email:
        print(f"Skipping record, missing email: {user_data.get('name')}")
        return

    stmt = select(UserTable).where(UserTable.email == user_email)
    result = await db.execute(stmt)
    db_user = result.scalar_one_or_none()

    if not db_user:
        # Create UserTable entry
        # For FastAPI-Users, password hashing is important.
        # This part might need to use UserManager if you want proper user creation.
        # For a simple seed, you might insert directly if you handle passwords appropriately (e.g. placeholder)
        # or if authentication isn't the focus of the seed.

        # Simplified direct insertion (use with caution for passwords)
        new_user_id = uuid.uuid4()
        db_user = UserTable(
            id=new_user_id,
            email=user_email,
            hashed_password=user_data.get("hashed_password", "seeded_placeholder_hash"),  # NOT SECURE FOR REAL USERS
            is_active=user_data.get("is_active", True),
            is_verified=user_data.get("is_verified", True),
            is_superuser=user_data.get("is_superuser", False),
            first_name=user_data.get("first_name"),
            last_name=user_data.get("last_name"),
        )
        db.add(db_user)
        await db.flush()  # Get the ID if auto-generated by DB, though we use UUID
        print(f"Created user: {user_email}")
    else:
        print(f"User already exists: {user_email}")
        # Optionally update existing user fields if needed
        # db_user.first_name = user_data.get("first_name", db_user.first_name)
        # ...

    # Create/Update UserProfileTable
    profile_data = user_data.get("profile")
    if profile_data:
        stmt_profile = select(UserProfileTable).where(UserProfileTable.user_id == db_user.id)
        result_profile = await db.execute(stmt_profile)
        db_profile = result_profile.scalar_one_or_none()

        if not db_profile:
            db_profile = UserProfileTable(user_id=db_user.id, **profile_data)
            db.add(db_profile)
            print(f"Created profile for user: {user_email}")
        else:
            # Update existing profile
            for key, value in profile_data.items():
                setattr(db_profile, key, value)
            print(f"Updated profile for user: {user_email}")

    # Create/Update SafetyPlanTable
    safety_plan_data = user_data.get("safety_plan")
    if safety_plan_data:
        stmt_safety_plan = select(SafetyPlanTable).where(SafetyPlanTable.user_id == db_user.id)
        result_safety_plan = await db.execute(stmt_safety_plan)
        db_safety_plan = result_safety_plan.scalar_one_or_none()

        if not db_safety_plan:
            db_safety_plan = SafetyPlanTable(user_id=db_user.id, **safety_plan_data)
            db.add(db_safety_plan)
            print(f"Created safety plan for user: {user_email}")
        else:
            # Update existing safety plan
            for key, value in safety_plan_data.items():
                setattr(db_safety_plan, key, value)
            print(f"Updated safety plan for user: {user_email}")


async def main():
    # await create_db_and_tables() # Ensure tables exist

    # Example: Load from a JSONL file
    # each line is a JSON object:
    # {"email": "user1@example.com", "first_name": "Test", "last_name": "User1",
    #  "profile": {"name": "Test User1", "gender_identity_pronouns": "they/them", ...},
    #  "safety_plan": {"step_1_warning_signs": "Feeling down", ...}}

    data_file = Path(__file__).parent.parent / "data" / "seed_users.jsonl"  # Adjust path

    if not data_file.exists():
        print(f"Data file not found: {data_file}")
        return

    async with get_async_session_context() as db:
        with open(data_file, "r") as f:
            for line in f:
                try:
                    user_data_item = json.loads(line)
                    await seed_user_data(db, user_data_item)
                except json.JSONDecodeError as e:
                    print(f"Skipping invalid JSON line: {line.strip()} - Error: {e}")
                except Exception as e:
                    print(f"Error processing line: {line.strip()} - Error: {e}")
        await db.commit()
    print("Data seeding complete.")


if __name__ == "__main__":
    # Ensure your DB_URL is set in environment or config for get_async_session_context
    # Example: os.environ["DB_URL"] = "sqlite+aiosqlite:///./test_seed.db"
    # Make sure your Alembic migrations have run against this DB first.
    asyncio.run(main())
